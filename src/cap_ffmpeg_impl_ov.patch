--- cap_ffmpeg_impl.hpp	2023-07-04 12:24:00.592937230 +0200
+++ cap_ffmpeg_impl_ov.hpp	2023-07-05 10:17:26.783277457 +0200
@@ -40,19 +40,82 @@
 //
 //M*/
 
-#include <opencv2/core/utils/configuration.private.hpp>
-#include "cap_ffmpeg_legacy_api.hpp"
-#include "opencv2/core/utils/logger.hpp"
-#include "cap_interface.hpp"
+/* ATTENTION:
+*
+* This file was generated from
+*
+* https://github.com/opencv/opencv/blob/4.x/modules/videoio/src/cap_ffmpeg_impl.hpp
+* commit 61d48dd0f8d1cc1a115d26998705a61478f64a3c
+*
+* and applying the patches in cap_ffmpeg_impl_ov.patch
+*/
+
+/*
+	tested against following combinations:
 
-using namespace cv;
+	$ sudo ./run.sh | grep -iP "version|name"
+
+	PRETTY_NAME="Debian GNU/Linux 10 (buster)"
+	NAME="Debian GNU/Linux"
+	OCTAVE_VERSION = 4.4.1
+	FFmpeg_versions = Lavu56.22.100, SwS5.3.100, Lavc58.35.100, Lavf58.20.100  <-- lowest
+
+	PRETTY_NAME="Debian GNU/Linux 11 (bullseye)"
+	NAME="Debian GNU/Linux"
+	OCTAVE_VERSION = 6.2.0
+	FFmpeg_versions = Lavu56.51.100, SwS5.7.100, Lavc58.91.100, Lavf58.45.100
+
+	PRETTY_NAME="Debian GNU/Linux 12 (bookworm)"
+	NAME="Debian GNU/Linux"
+	OCTAVE_VERSION = 7.3.0
+	FFmpeg_versions = Lavu57.28.100, SwS6.7.100, Lavc59.37.100, Lavf59.27.100
+
+	NAME=Fedora
+	VERSION="31 (Container Image)"
+	OCTAVE_VERSION = 5.1.0
+	FFmpeg_versions = Lavu56.31.100, SwS5.5.100, Lavc58.54.100, Lavf58.29.100
+
+	NAME=Fedora
+	VERSION="33 (Container Image)"
+	OCTAVE_VERSION = 5.2.0
+	FFmpeg_versions = Lavu56.51.100, SwS5.7.100, Lavc58.91.100, Lavf58.45.100
+
+	NAME="Fedora Linux"
+	VERSION="38 (Container Image)"
+	OCTAVE_VERSION = 7.3.0
+	FFmpeg_versions = Lavu58.2.100, SwS7.1.100, Lavc60.3.100, Lavf60.3.100
+
+	NAME="Ubuntu"
+	VERSION="20.04.6 LTS (Focal Fossa)"
+	OCTAVE_VERSION = 5.2.0
+	FFmpeg_versions = Lavu56.31.100, SwS5.5.100, Lavc58.54.100, Lavf58.29.100
+
+	PRETTY_NAME="Ubuntu 22.04.2 LTS"
+	NAME="Ubuntu"
+	OCTAVE_VERSION = 6.4.0
+	FFmpeg_versions = Lavu56.70.100, SwS5.9.100, Lavc58.134.100, Lavf58.76.100
+
+	PRETTY_NAME="Ubuntu 23.04"
+	NAME="Ubuntu"
+	OCTAVE_VERSION = 7.3.0
+	FFmpeg_versions = Lavu57.28.100, SwS6.7.100, Lavc59.37.100, Lavf59.27.100
+*/
+
+// dummy until implemented
+#define CV_LOG_DEBUG(tag, ...) ;
+#define CV_LOG_ERROR(tag, ...) ;
+#define CV_LOG_WARNING(tag, ...) ;
+
+#define CV_Assert(x) assert(x);
+
+#define CV_8U   0
+#define CV_16U  2
 
-#if !(defined(_WIN32) || defined(WINCE))
-# include <pthread.h>
-#endif
 #include <algorithm>
 #include <limits>
-#include <string.h>
+#include <string>
+#include <mutex>
+#include <octave/oct.h>
 
 #ifndef __OPENCV_BUILD
 #define CV_FOURCC(c1, c2, c3, c4) (((c1) & 255) + (((c2) & 255) << 8) + (((c3) & 255) << 16) + (((c4) & 255) << 24))
@@ -83,16 +146,8 @@
 
 #include <libavutil/mathematics.h>
 #include <libavutil/opt.h>
-// https://github.com/FFmpeg/FFmpeg/blame/d79c240196f43b93bd204363f1facc270029f113/doc/APIchanges#L1689-L1695
-#if LIBAVUTIL_BUILD >= (LIBAVUTIL_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(52, 85, 100) : CALC_FFMPEG_VERSION(53, 15, 0))
 #include <libavutil/display.h>
-#endif
-
-#if LIBAVUTIL_BUILD >= (LIBAVUTIL_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(51, 63, 100) : CALC_FFMPEG_VERSION(54, 6, 0))
 #include <libavutil/imgutils.h>
-#endif
 
 #include <libavcodec/avcodec.h>
 #include <libswscale/swscale.h>
@@ -100,16 +155,6 @@
 #include <libavdevice/avdevice.h>
 #endif
 
-// https://github.com/FFmpeg/FFmpeg/blob/b6af56c034759b81985f8ea094e41cbd5f7fecfb/doc/APIchanges#L602-L605
-#if LIBAVFORMAT_BUILD < CALC_FFMPEG_VERSION(58, 9, 100)
-#  define CV_FFMPEG_REGISTER
-#endif
-
-// https://github.com/FFmpeg/FFmpeg/blob/b6af56c034759b81985f8ea094e41cbd5f7fecfb/doc/APIchanges#L654-L657
-#if LIBAVCODEC_BUILD < CALC_FFMPEG_VERSION(58, 9, 100)
-#  define CV_FFMPEG_LOCKMGR
-#endif
-
 // https://github.com/FFmpeg/FFmpeg/blob/b6af56c034759b81985f8ea094e41cbd5f7fecfb/doc/APIchanges#L390-L392
 #if LIBAVCODEC_BUILD >= CALC_FFMPEG_VERSION(58, 87, 100)
 #include <libavcodec/bsf.h>
@@ -121,63 +166,21 @@
 #if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(59, 0, 100)
 #  define CV_FFMPEG_FMT_CONST const
 #else
+// for example Debian bullseye has Lavu56.51.100, SwS5.7.100, Lavc58.91.100, Lavf58.45.100
 #  define CV_FFMPEG_FMT_CONST
 #endif
 
-// https://github.com/FFmpeg/FFmpeg/blob/b6af56c034759b81985f8ea094e41cbd5f7fecfb/doc/APIchanges#L623-L624
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(58, 7, 100)
-#  define CV_FFMPEG_URL
-#endif
-
-// AVStream.codec deprecated in favor of AVStream.codecpar
-// https://github.com/FFmpeg/FFmpeg/blob/b6af56c034759b81985f8ea094e41cbd5f7fecfb/doc/APIchanges#L1039-L1040
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(59, 16, 100)
-//#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(57, 33, 100)
-#  define CV_FFMPEG_CODECPAR
-#  define CV_FFMPEG_CODEC_FIELD codecpar
-#else
-#  define CV_FFMPEG_CODEC_FIELD codec
-#endif
-
 #if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(59, 16, 100)
 #  define CV_FFMPEG_PTS_FIELD pts
 #else
+// for example Debian bullseye has Lavu56.51.100, SwS5.7.100, Lavc58.91.100, Lavf58.45.100
 #  define CV_FFMPEG_PTS_FIELD pkt_pts
 #endif
 
-// https://github.com/FFmpeg/FFmpeg/blob/b6af56c034759b81985f8ea094e41cbd5f7fecfb/doc/APIchanges#L1757-L1758
-#if LIBAVUTIL_BUILD < CALC_FFMPEG_VERSION(52, 63, 100)
-inline static AVRational av_make_q(int num, int den)
-{
-    AVRational res;
-    res.num = num;
-    res.den = den;
-    return res;
-}
-#endif
-
-
-
 #ifdef __cplusplus
 }
 #endif
 
-// GCC 4.x compilation bug. Details: https://github.com/opencv/opencv/issues/20292
-#if (defined(__GNUC__) && __GNUC__ < 5) && !defined(__clang__)
-#undef USE_AV_HW_CODECS
-#define USE_AV_HW_CODECS 0
-#endif
-
-//#define USE_AV_HW_CODECS 0
-#ifndef USE_AV_HW_CODECS
-#if LIBAVUTIL_VERSION_MAJOR >= 56 // FFMPEG 4.0+
-#define USE_AV_HW_CODECS 1
-#include "cap_ffmpeg_hw.hpp"
-#else
-#define USE_AV_HW_CODECS 0
-#endif
-#endif
-
 #if defined _MSC_VER && _MSC_VER >= 1200
 #pragma warning( default: 4244 4510 4610 )
 #endif
@@ -188,6 +191,15 @@
 #define CV_WARN(message) fprintf(stderr, "warning: %s (%s:%d)\n", message, __FILE__, __LINE__)
 #endif
 
+static int global_err;
+
+std::string get_last_err_msg ()
+{
+  char err_buf[80];
+  av_strerror (global_err, err_buf, 80);
+  return err_buf;
+}
+
 #if defined _WIN32
     #include <windows.h>
     #if defined _MSC_VER && _MSC_VER < 1900
@@ -205,11 +217,13 @@
 #if defined __APPLE__
     #include <sys/sysctl.h>
     #include <mach/clock.h>
-    #include <mach/mach.h>
+    #include <mach/mach_host.h>
+    #include <mach/mach_init.h>
+    #include <mach/mach_traps.h>
+    #include <mach/mach_port.h>
 #endif
 #endif
 
-
 #if defined(__APPLE__)
 #define AV_NOPTS_VALUE_ ((int64_t)0x8000000000000000LL)
 #else
@@ -220,44 +234,13 @@
 #define AVERROR_EOF (-MKTAG( 'E','O','F',' '))
 #endif
 
-#if LIBAVCODEC_BUILD >= CALC_FFMPEG_VERSION(54,25,0)
-#  define CV_CODEC_ID AVCodecID
-#  define CV_CODEC(name) AV_##name
-#else
-#  define CV_CODEC_ID CodecID
-#  define CV_CODEC(name) name
-#endif
+#define CV_CODEC_ID AVCodecID
+#define CV_CODEC(name) AV_##name
 
 #ifndef PKT_FLAG_KEY
 #define PKT_FLAG_KEY AV_PKT_FLAG_KEY
 #endif
 
-#if LIBAVUTIL_BUILD >= (LIBAVUTIL_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(52, 38, 100) : CALC_FFMPEG_VERSION(52, 13, 0))
-#define USE_AV_FRAME_GET_BUFFER 1
-#else
-#define USE_AV_FRAME_GET_BUFFER 0
-#ifndef AV_NUM_DATA_POINTERS // required for 0.7.x/0.8.x ffmpeg releases
-#define AV_NUM_DATA_POINTERS 4
-#endif
-#endif
-
-
-#ifndef USE_AV_INTERRUPT_CALLBACK
-#define USE_AV_INTERRUPT_CALLBACK 1
-#endif
-
-#ifndef USE_AV_SEND_FRAME_API
-// https://github.com/FFmpeg/FFmpeg/commit/7fc329e2dd6226dfecaa4a1d7adf353bf2773726
-#if LIBAVCODEC_VERSION_MICRO >= 100 \
-    && LIBAVCODEC_BUILD >= CALC_FFMPEG_VERSION(57, 37, 100)
-#define USE_AV_SEND_FRAME_API 1
-#else
-#define USE_AV_SEND_FRAME_API 0
-#endif
-#endif
-
-#if USE_AV_INTERRUPT_CALLBACK
 #define LIBAVFORMAT_INTERRUPT_OPEN_DEFAULT_TIMEOUT_MS 30000
 #define LIBAVFORMAT_INTERRUPT_READ_DEFAULT_TIMEOUT_MS 30000
 
@@ -372,8 +355,6 @@
 
     return milliseconds;
 }
-#endif // USE_AV_INTERRUPT_CALLBACK
-
 
 struct Image_FFMPEG
 {
@@ -384,7 +365,6 @@
 };
 
 
-#if USE_AV_INTERRUPT_CALLBACK
 struct AVInterruptCallbackMetadata
 {
     timespec value;
@@ -396,38 +376,9 @@
 static
 inline const char* _opencv_avcodec_get_name(CV_CODEC_ID id)
 {
-#if LIBAVCODEC_VERSION_MICRO >= 100 \
-    && LIBAVCODEC_BUILD >= CALC_FFMPEG_VERSION(53, 47, 100)
     return avcodec_get_name(id);
-#else
-    const AVCodecDescriptor *cd;
-    AVCodec *codec;
-
-    if (id == AV_CODEC_ID_NONE)
-    {
-        return "none";
-    }
-    cd = avcodec_descriptor_get(id);
-    if (cd)
-    {
-        return cd->name;
-    }
-    codec = avcodec_find_decoder(id);
-    if (codec)
-    {
-        return codec->name;
-    }
-    codec = avcodec_find_encoder(id);
-    if (codec)
-    {
-        return codec->name;
-    }
-
-    return "unknown_codec";
-#endif
 }
 
-
 static
 inline int _opencv_ffmpeg_interrupt_callback(void *ptr)
 {
@@ -446,62 +397,28 @@
 
     return metadata->timeout ? -1 : 0;
 }
-#endif
 
 static
 inline void _opencv_ffmpeg_av_packet_unref(AVPacket *pkt)
 {
-#if LIBAVCODEC_BUILD >= (LIBAVCODEC_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(55, 25, 100) : CALC_FFMPEG_VERSION(55, 16, 0))
     av_packet_unref(pkt);
-#else
-    av_free_packet(pkt);
-#endif
 };
 
 static
 inline void _opencv_ffmpeg_av_image_fill_arrays(void *frame, uint8_t *ptr, enum AVPixelFormat pix_fmt, int width, int height)
 {
-#if LIBAVUTIL_BUILD >= (LIBAVUTIL_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(51, 63, 100) : CALC_FFMPEG_VERSION(54, 6, 0))
     av_image_fill_arrays(((AVFrame*)frame)->data, ((AVFrame*)frame)->linesize, ptr, pix_fmt, width, height, 1);
-#else
-    avpicture_fill((AVPicture*)frame, ptr, pix_fmt, width, height);
-#endif
 };
 
 static
 inline int _opencv_ffmpeg_av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height)
 {
-#if LIBAVUTIL_BUILD >= (LIBAVUTIL_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(51, 63, 100) : CALC_FFMPEG_VERSION(54, 6, 0))
     return av_image_get_buffer_size(pix_fmt, width, height, 1);
-#else
-    return avpicture_get_size(pix_fmt, width, height);
-#endif
 };
 
 static AVRational _opencv_ffmpeg_get_sample_aspect_ratio(AVStream *stream)
 {
-#if LIBAVUTIL_VERSION_MICRO >= 100 && LIBAVUTIL_BUILD >= CALC_FFMPEG_VERSION(54, 5, 100)
     return av_guess_sample_aspect_ratio(NULL, stream, NULL);
-#else
-    AVRational undef = {0, 1};
-
-    // stream
-    AVRational ratio = stream ? stream->sample_aspect_ratio : undef;
-    av_reduce(&ratio.num, &ratio.den, ratio.num, ratio.den, INT_MAX);
-    if (ratio.num > 0 && ratio.den > 0)
-        return ratio;
-
-    // codec
-    ratio  = stream && stream->codec ? stream->codec->sample_aspect_ratio : undef;
-    av_reduce(&ratio.num, &ratio.den, ratio.num, ratio.den, INT_MAX);
-    if (ratio.num > 0 && ratio.den > 0)
-        return ratio;
-
-    return undef;
-#endif
 }
 
 inline static std::string _opencv_ffmpeg_get_error_string(int error_code)
@@ -514,17 +431,20 @@
         return std::string("Unknown error");
 }
 
-struct CvCapture_FFMPEG
+static bool capture_type_loaded = false;
+
+class CvCapture_FFMPEG: public octave_base_value
 {
-    bool open(const char* filename, const VideoCaptureParameters& params);
+  public:
+    CvCapture_FFMPEG ();
+
+    bool open(const char* filename);
     void close();
 
-    double getProperty(int) const;
+    //double getProperty(int) const;
     bool setProperty(int, double);
     bool grabFrame();
     bool retrieveFrame(int flag, unsigned char** data, int* step, int* width, int* height, int* cn, int* depth);
-    bool retrieveHWFrame(cv::OutputArray output);
-    void rotateFrame(cv::Mat &mat) const;
 
     void init();
 
@@ -537,6 +457,14 @@
     double  get_fps() const;
     int64_t get_bitrate() const;
 
+    AVRational get_sample_aspect_ratio () const
+      { return _opencv_ffmpeg_get_sample_aspect_ratio(ic->streams[video_stream]); }
+
+    const char* get_video_codec_name () const
+      {
+        return _opencv_avcodec_get_name(video_st->codecpar->codec_id);
+      }
+
     double  r2d(AVRational r) const;
     int64_t dts_to_frame_number(int64_t dts);
     double  dts_to_sec(int64_t dts) const;
@@ -570,11 +498,9 @@
     char              * filename;
 
     AVDictionary *dict;
-#if USE_AV_INTERRUPT_CALLBACK
     int open_timeout;
     int read_timeout;
     AVInterruptCallbackMetadata interrupt_metadata;
-#endif
 
     bool setRaw();
     bool processRawPacket();
@@ -582,17 +508,46 @@
     bool rawModeInitialized;
     bool convertRGB;
     AVPacket packet_filtered;
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(58, 20, 100)
     AVBSFContext* bsfc;
- #else
-    AVBitStreamFilterContext* bsfc;
-#endif
-    VideoAccelerationType va_type;
-    int hw_device;
     int use_opencl;
     int extraDataIdx;
+
+  bool is_constant (void) const
+  {
+	return true;
+  }
+  bool is_defined (void) const
+  {
+	return true;
+  }
+
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+
+  void print (std::ostream & os, bool pr_as_read_syntax = false)
+  {
+	os << "CvCapture_FFMPEG:" << std::endl;
+	if (filename)
+	  os << "  filename           = " << filename << std::endl;
+	os << "  get_total_frames() = " << get_total_frames() << std::endl;
+	os << "  get_duration_sec() = " << get_duration_sec() << std::endl;
+	os << "  get_fps()          = " << get_fps() << std::endl;
+	os << "  get_bitrate()      = " << get_bitrate() << std::endl;
+	os << "  width              = " << frame.width << std::endl;
+	os << "  height             = " << frame.height << std::endl;
+	os << "  frame_number       = " << frame_number << std::endl;
+	os << "  video_codec_name   = " << get_video_codec_name () << std::endl;
+	AVRational s = get_sample_aspect_ratio ();
+	os << "  aspect_ration_num  = " << s.num << std::endl;
+	os << "  aspect_ration_den  = " << s.den << std::endl;
+  }
+
 };
 
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(CvCapture_FFMPEG, "CvCapture_FFMPEG", "CvCapture_FFMPEG");
+
+CvCapture_FFMPEG::CvCapture_FFMPEG ()
+  : octave_base_value () { init (); };
+
 void CvCapture_FFMPEG::init()
 {
 #ifdef HAVE_FFMPEG_LIBAVDEVICE
@@ -618,18 +573,12 @@
     eps_zero = 0.000025;
 
     rotation_angle = 0;
-
-#if (LIBAVUTIL_BUILD >= CALC_FFMPEG_VERSION(52, 92, 100))
     rotation_auto = true;
-#else
-    rotation_auto = false;
-#endif
+
     dict = NULL;
 
-#if USE_AV_INTERRUPT_CALLBACK
     open_timeout = LIBAVFORMAT_INTERRUPT_OPEN_DEFAULT_TIMEOUT_MS;
     read_timeout = LIBAVFORMAT_INTERRUPT_READ_DEFAULT_TIMEOUT_MS;
-#endif
 
     rawMode = false;
     rawModeInitialized = false;
@@ -637,8 +586,6 @@
     memset(&packet_filtered, 0, sizeof(packet_filtered));
     av_init_packet(&packet_filtered);
     bsfc = NULL;
-    va_type = cv::VIDEO_ACCELERATION_NONE;  // TODO OpenCV 5.0: change to _ANY?
-    hw_device = -1;
     use_opencl = 0;
     extraDataIdx = 1;
 }
@@ -654,30 +601,18 @@
 
     if( picture )
     {
-#if LIBAVCODEC_BUILD >= (LIBAVCODEC_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(55, 45, 101) : CALC_FFMPEG_VERSION(55, 28, 1))
         av_frame_free(&picture);
-#elif LIBAVCODEC_BUILD >= (LIBAVCODEC_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(54, 59, 100) : CALC_FFMPEG_VERSION(54, 28, 0))
-        avcodec_free_frame(&picture);
-#else
-        av_free(picture);
-#endif
     }
 
     if( video_st )
     {
-#ifdef CV_FFMPEG_CODECPAR
         avcodec_close( context );
-#endif
         video_st = NULL;
     }
 
     if (context)
     {
-#ifdef CV_FFMPEG_CODECPAR
         avcodec_free_context(&context);
-#endif
     }
 
     if( ic )
@@ -686,15 +621,7 @@
         ic = NULL;
     }
 
-#if USE_AV_FRAME_GET_BUFFER
     av_frame_unref(&rgb_picture);
-#else
-    if( rgb_picture.data[0] )
-    {
-        free( rgb_picture.data[0] );
-        rgb_picture.data[0] = 0;
-    }
-#endif
 
     // free last packet if exist
     if (packet.data) {
@@ -713,11 +640,7 @@
 
     if (bsfc)
     {
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(58, 20, 100)
         av_bsf_free(&bsfc);
-#else
-        av_bitstream_filter_close(bsfc);
-#endif
     }
 
     init();
@@ -860,39 +783,6 @@
 
 static ImplMutex _mutex;
 
-#ifdef CV_FFMPEG_LOCKMGR
-static int LockCallBack(void **mutex, AVLockOp op)
-{
-    ImplMutex* localMutex = reinterpret_cast<ImplMutex*>(*mutex);
-    switch (op)
-    {
-        case AV_LOCK_CREATE:
-            localMutex = new ImplMutex();
-            if (!localMutex)
-                return 1;
-            *mutex = localMutex;
-            if (!*mutex)
-                return 1;
-        break;
-
-        case AV_LOCK_OBTAIN:
-            localMutex->lock();
-        break;
-
-        case AV_LOCK_RELEASE:
-            localMutex->unlock();
-        break;
-
-        case AV_LOCK_DESTROY:
-            delete localMutex;
-            localMutex = NULL;
-            *mutex = NULL;
-        break;
-    }
-    return 0;
-}
-#endif
-
 static void ffmpeg_log_callback(void *ptr, int level, const char *fmt, va_list vargs)
 {
     static bool skip_header = false;
@@ -911,63 +801,61 @@
 public:
     static void init(const bool threadSafe)
     {
-        std::unique_lock<cv::Mutex> lock(_mutex, std::defer_lock);
-        if(!threadSafe)
-            lock.lock();
+		AutoLock lock(_mutex);
         static InternalFFMpegRegister instance;
-        initLogger_();  // update logger setup unconditionally (GStreamer's libav plugin may override these settings)
-    }
-    static void initLogger_()
-    {
-#ifndef NO_GETENV
-        char* debug_option = getenv("OPENCV_FFMPEG_DEBUG");
-        char* level_option = getenv("OPENCV_FFMPEG_LOGLEVEL");
-        int level = AV_LOG_VERBOSE;
-        if (level_option != NULL)
-        {
-            level = atoi(level_option);
-        }
-        if ( (debug_option != NULL) || (level_option != NULL) )
-        {
-            av_log_set_level(level);
-            av_log_set_callback(ffmpeg_log_callback);
-        }
-        else
-#endif
-        {
-            av_log_set_level(AV_LOG_ERROR);
-        }
     }
-
-public:
     InternalFFMpegRegister()
     {
         avformat_network_init();
 
-#ifdef CV_FFMPEG_REGISTER
-        /* register all codecs, demux and protocols */
-        av_register_all();
-#endif
-
-#ifdef CV_FFMPEG_LOCKMGR
-        /* register a callback function for synchronization */
-        av_lockmgr_register(&LockCallBack);
-#endif
     }
     ~InternalFFMpegRegister()
     {
-#ifdef CV_FFMPEG_LOCKMGR
-        av_lockmgr_register(NULL);
-#endif
         av_log_set_callback(NULL);
     }
 };
 
+static int get_number_of_cpus(void)
+{
+#if defined _WIN32
+    SYSTEM_INFO sysinfo;
+    GetSystemInfo( &sysinfo );
+
+    return (int)sysinfo.dwNumberOfProcessors;
+#elif defined __linux__ || defined __HAIKU__
+    return (int)sysconf( _SC_NPROCESSORS_ONLN );
+#elif defined __APPLE__
+    int numCPU=0;
+    int mib[4];
+    size_t len = sizeof(numCPU);
+
+    // set the mib for hw.ncpu
+    mib[0] = CTL_HW;
+    mib[1] = HW_AVAILCPU;  // alternatively, try HW_NCPU;
+
+    // get the number of CPUs from the system
+    sysctl(mib, 2, &numCPU, &len, NULL, 0);
+
+    if( numCPU < 1 )
+    {
+        mib[1] = HW_NCPU;
+        sysctl( mib, 2, &numCPU, &len, NULL, 0 );
+
+        if( numCPU < 1 )
+            numCPU = 1;
+    }
+
+    return (int)numCPU;
+#else
+    return 1;
+#endif
+}
+
 inline void fill_codec_context(AVCodecContext * enc, AVDictionary * dict)
 {
     if (!enc->thread_count)
     {
-        int nCpus = cv::getNumberOfCPUs();
+        int nCpus = get_number_of_cpus();
         int requestedThreads = std::min(nCpus, 16);  // [OPENCV:FFMPEG:24] Application has requested XX threads. Using a thread count greater than 16 is not recommended.
         char* threads_option = getenv("OPENCV_FFMPEG_THREADS");
         if (threads_option != NULL)
@@ -989,13 +877,8 @@
             enc->skip_frame = AVDISCARD_DEFAULT;
         else if (strcmp(avdiscard_entry->value, "none") == 0)
             enc->skip_frame = AVDISCARD_NONE;
-        // NONINTRA flag was introduced with version bump at revision:
-        // https://github.com/FFmpeg/FFmpeg/commit/b152152df3b778d0a86dcda5d4f5d065b4175a7b
-        // This key is supported only for FFMPEG version
-#if LIBAVCODEC_VERSION_MICRO >= 100 && LIBAVCODEC_BUILD >= CALC_FFMPEG_VERSION(55, 67, 100)
         else if (strcmp(avdiscard_entry->value, "nonintra") == 0)
             enc->skip_frame = AVDISCARD_NONINTRA;
-#endif
         else if (strcmp(avdiscard_entry->value, "nonkey") == 0)
             enc->skip_frame = AVDISCARD_NONKEY;
         else if (strcmp(avdiscard_entry->value, "nonref") == 0)
@@ -1004,21 +887,19 @@
 }
 
 static bool isThreadSafe() {
-    const bool threadSafe = utils::getConfigurationParameterBool("OPENCV_FFMPEG_IS_THREAD_SAFE", false);
+    const bool threadSafe = false; //utils::getConfigurationParameterBool("OPENCV_FFMPEG_IS_THREAD_SAFE", false);
     if (threadSafe) {
         CV_LOG_WARNING(NULL, "VIDEOIO/FFMPEG: OPENCV_FFMPEG_IS_THREAD_SAFE == 1, all OpenCV locks removed, relying on FFmpeg to provide thread safety.  If FFmpeg is not thread safe isOpened() may return false when multiple threads try to call open() at the same time.");
     }
     return threadSafe;
 }
 
-bool CvCapture_FFMPEG::open(const char* _filename, const VideoCaptureParameters& params)
+bool CvCapture_FFMPEG::open(const char* _filename)
 {
     const bool threadSafe = isThreadSafe();
     InternalFFMpegRegister::init(threadSafe);
 
-    std::unique_lock<cv::Mutex> lock(_mutex, std::defer_lock);
-    if(!threadSafe)
-        lock.lock();
+	AutoLock lock(_mutex);
 
     unsigned i;
     bool valid = false;
@@ -1026,108 +907,25 @@
 
     close();
 
-    if (!params.empty())
-    {
-        convertRGB = params.get<bool>(CAP_PROP_CONVERT_RGB, true);
-        if (!convertRGB)
-        {
-            CV_LOG_WARNING(NULL, "VIDEOIO/FFMPEG: BGR conversion turned OFF, decoded frame will be "
-                                 "returned in its original format. "
-                                 "Multiplanar formats are not supported by the backend. "
-                                 "Only GRAY8/GRAY16LE pixel formats have been tested. "
-                                 "Use at your own risk.");
-        }
-        if (params.has(CAP_PROP_FORMAT))
-        {
-            int value = params.get<int>(CAP_PROP_FORMAT);
-            if (value == -1)
-            {
-                CV_LOG_INFO(NULL, "VIDEOIO/FFMPEG: enabled demuxer only mode: '" << (_filename ? _filename : "<NULL>") << "'");
-                rawMode = true;
-            }
-            else
-            {
-                CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: CAP_PROP_FORMAT parameter value is invalid/unsupported: " << value);
-                return false;
-            }
-        }
-        if (params.has(CAP_PROP_HW_ACCELERATION))
-        {
-            va_type = params.get<VideoAccelerationType>(CAP_PROP_HW_ACCELERATION);
-#if !USE_AV_HW_CODECS
-            if (va_type != VIDEO_ACCELERATION_NONE && va_type != VIDEO_ACCELERATION_ANY)
-            {
-                CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: FFmpeg backend is build without acceleration support. Can't handle CAP_PROP_HW_ACCELERATION parameter. Bailout");
-                return false;
-            }
-#endif
-        }
-        if (params.has(CAP_PROP_HW_DEVICE))
-        {
-            hw_device = params.get<int>(CAP_PROP_HW_DEVICE);
-            if (va_type == VIDEO_ACCELERATION_NONE && hw_device != -1)
-            {
-                CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: Invalid usage of CAP_PROP_HW_DEVICE without requested H/W acceleration. Bailout");
-                return false;
-            }
-            if (va_type == VIDEO_ACCELERATION_ANY && hw_device != -1)
-            {
-                CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: Invalid usage of CAP_PROP_HW_DEVICE with 'ANY' H/W acceleration. Bailout");
-                return false;
-            }
-        }
-        if (params.has(CAP_PROP_HW_ACCELERATION_USE_OPENCL)) {
-            use_opencl = params.get<int>(CAP_PROP_HW_ACCELERATION_USE_OPENCL);
-        }
-#if USE_AV_INTERRUPT_CALLBACK
-        if (params.has(CAP_PROP_OPEN_TIMEOUT_MSEC))
-        {
-            open_timeout = params.get<int>(CAP_PROP_OPEN_TIMEOUT_MSEC);
-        }
-        if (params.has(CAP_PROP_READ_TIMEOUT_MSEC))
-        {
-            read_timeout = params.get<int>(CAP_PROP_READ_TIMEOUT_MSEC);
-        }
-#endif
-        if (params.has(CAP_PROP_N_THREADS))
-        {
-            nThreads = params.get<int>(CAP_PROP_N_THREADS);
-        }
-        if (params.warnUnusedParameters())
-        {
-            CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: unsupported parameters in .open(), see logger INFO channel for details. Bailout");
-            return false;
-        }
-    }
+    convertRGB = true;
 
-#if USE_AV_INTERRUPT_CALLBACK
-    /* interrupt callback */
-    interrupt_metadata.timeout_after_ms = open_timeout;
+    interrupt_metadata.timeout_after_ms = LIBAVFORMAT_INTERRUPT_OPEN_DEFAULT_TIMEOUT_MS;
     get_monotonic_time(&interrupt_metadata.value);
 
     ic = avformat_alloc_context();
     ic->interrupt_callback.callback = _opencv_ffmpeg_interrupt_callback;
     ic->interrupt_callback.opaque = &interrupt_metadata;
-#endif
 
 #ifndef NO_GETENV
     char* options = getenv("OPENCV_FFMPEG_CAPTURE_OPTIONS");
     if(options == NULL)
     {
-#if LIBAVFORMAT_VERSION_MICRO >= 100  && LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(55, 48, 100)
         av_dict_set(&dict, "rtsp_flags", "prefer_tcp", 0);
-#else
-        av_dict_set(&dict, "rtsp_transport", "tcp", 0);
-#endif
     }
     else
     {
         CV_LOG_DEBUG(NULL, "VIDEOIO/FFMPEG: using capture options from environment: " << options);
-#if LIBAVUTIL_BUILD >= (LIBAVUTIL_VERSION_MICRO >= 100 ? CALC_FFMPEG_VERSION(52, 17, 100) : CALC_FFMPEG_VERSION(52, 7, 0))
         av_dict_parse_string(&dict, options, ";", "|", 0);
-#else
-        av_dict_set(&dict, "rtsp_transport", "tcp", 0);
-#endif
     }
 #else
     av_dict_set(&dict, "rtsp_transport", "tcp", 0);
@@ -1139,94 +937,41 @@
       input_format = av_find_input_format(entry->value);
     }
 
-    int err = avformat_open_input(&ic, _filename, input_format, &dict);
+    global_err = avformat_open_input(&ic, _filename, input_format, &dict);
 
-    if (err < 0)
+    if (global_err < 0)
     {
         CV_WARN("Error opening file");
         CV_WARN(_filename);
         goto exit_func;
     }
-    err = avformat_find_stream_info(ic, NULL);
-    if (err < 0)
+    global_err = avformat_find_stream_info(ic, NULL);
+    if (global_err < 0)
     {
-        CV_LOG_WARNING(NULL, "Unable to read codec parameters from stream (" << _opencv_ffmpeg_get_error_string(err) << ")");
+        CV_LOG_WARNING(NULL, "Unable to read codec parameters from stream (" << _opencv_ffmpeg_get_error_string(global_err) << ")");
         goto exit_func;
     }
     for(i = 0; i < ic->nb_streams; i++)
     {
-#ifndef CV_FFMPEG_CODECPAR
-        context = ic->streams[i]->codec;
-        AVCodecID codec_id = context->codec_id;
-        AVMediaType codec_type = context->codec_type;
-#else
         AVCodecParameters* par = ic->streams[i]->codecpar;
         AVCodecID codec_id = par->codec_id;
         AVMediaType codec_type = par->codec_type;
-#endif
 
         if( AVMEDIA_TYPE_VIDEO == codec_type && video_stream < 0)
         {
             // backup encoder' width/height
-#ifndef CV_FFMPEG_CODECPAR
-            int enc_width = context->width;
-            int enc_height = context->height;
-#else
             int enc_width = par->width;
             int enc_height = par->height;
-#endif
 
             CV_LOG_DEBUG(NULL, "FFMPEG: stream[" << i << "] is video stream with codecID=" << (int)codec_id
                     << " width=" << enc_width
                     << " height=" << enc_height
             );
 
-
-#if !USE_AV_HW_CODECS
-            va_type = VIDEO_ACCELERATION_NONE;
-#endif
-
             // find and open decoder, try HW acceleration types specified in 'hw_acceleration' list (in order)
             const AVCodec *codec = NULL;
-            err = -1;
-#if USE_AV_HW_CODECS
-            HWAccelIterator accel_iter(va_type, false/*isEncoder*/, dict);
-            while (accel_iter.good())
-            {
-#else
+            global_err = -1;
             do {
-#endif
-#if USE_AV_HW_CODECS
-                accel_iter.parse_next();
-                AVHWDeviceType hw_type = accel_iter.hw_type();
-                if (hw_type != AV_HWDEVICE_TYPE_NONE)
-                {
-                    CV_LOG_DEBUG(NULL, "FFMPEG: trying to configure H/W acceleration: '" << accel_iter.hw_type_device_string() << "'");
-                    AVPixelFormat hw_pix_fmt = AV_PIX_FMT_NONE;
-                    codec = hw_find_codec(codec_id, hw_type, av_codec_is_decoder, accel_iter.disabled_codecs().c_str(), &hw_pix_fmt);
-                    if (codec)
-                    {
-#ifdef CV_FFMPEG_CODECPAR
-                        context = avcodec_alloc_context3(codec);
-#endif
-                        CV_Assert(context);
-                        context->get_format = avcodec_default_get_format;
-                        if (context->hw_device_ctx) {
-                            av_buffer_unref(&context->hw_device_ctx);
-                        }
-                        if (hw_pix_fmt != AV_PIX_FMT_NONE)
-                            context->get_format = hw_get_format_callback; // set callback to select HW pixel format, not SW format
-                        context->hw_device_ctx = hw_create_device(hw_type, hw_device, accel_iter.device_subname(), use_opencl != 0);
-                        if (!context->hw_device_ctx)
-                        {
-                            context->get_format = avcodec_default_get_format;
-                            CV_LOG_DEBUG(NULL, "FFMPEG: ... can't create H/W device: '" << accel_iter.hw_type_device_string() << "'");
-                            codec = NULL;
-                        }
-                    }
-                }
-                else if (hw_type == AV_HWDEVICE_TYPE_NONE)
-#endif // USE_AV_HW_CODECS
                 {
                     AVDictionaryEntry* video_codec_param = av_dict_get(dict, "video_codec", NULL, 0);
                     if (video_codec_param == NULL)
@@ -1234,7 +979,7 @@
                         codec = avcodec_find_decoder(codec_id);
                         if (!codec)
                         {
-                            CV_LOG_ERROR(NULL, "Could not find decoder for codec_id=" << (int)codec_id);
+                            fprintf (stderr, "Could not find decoder for codec_id = %i", codec_id);
                         }
                     }
                     else
@@ -1248,41 +993,26 @@
                     }
                     if (codec)
                     {
-#ifdef CV_FFMPEG_CODECPAR
                         context = avcodec_alloc_context3(codec);
-#endif
                         CV_Assert(context);
                     }
                 }
                 if (!codec)
                 {
-#ifdef CV_FFMPEG_CODECPAR
                     avcodec_free_context(&context);
-#endif
                     continue;
                 }
                 context->thread_count = nThreads;
                 fill_codec_context(context, dict);
-#ifdef CV_FFMPEG_CODECPAR
                 avcodec_parameters_to_context(context, par);
-#endif
-                err = avcodec_open2(context, codec, NULL);
-                if (err >= 0) {
-#if USE_AV_HW_CODECS
-                    va_type = hw_type_to_va_type(hw_type);
-                    if (hw_type != AV_HWDEVICE_TYPE_NONE && hw_device < 0)
-                        hw_device = 0;
-#endif
+                global_err = avcodec_open2(context, codec, NULL);
+                if (global_err >= 0) {
                     break;
                 } else {
-                    CV_LOG_ERROR(NULL, "Could not open codec " << codec->name << ", error: " << err);
+                    CV_LOG_ERROR(NULL, "Could not open codec " << codec->name << ", error: " << global_err);
                 }
-#if USE_AV_HW_CODECS
-            }  // while (accel_iter.good())
-#else
             } while (0);
-#endif
-            if (err < 0) {
+            if (global_err < 0) {
                 CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: Failed to initialize VideoCapture");
                 goto exit_func;
             }
@@ -1295,13 +1025,7 @@
 
             video_stream = i;
             video_st = ic->streams[i];
-#if LIBAVCODEC_BUILD >= (LIBAVCODEC_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(55, 45, 101) : CALC_FFMPEG_VERSION(55, 28, 1))
             picture = av_frame_alloc();
-#else
-            picture = avcodec_alloc_frame();
-#endif
-
             frame.width = context->width;
             frame.height = context->height;
             frame.step = 0;
@@ -1316,10 +1040,8 @@
 
 exit_func:
 
-#if USE_AV_INTERRUPT_CALLBACK
     // deactivate interrupt callback
     interrupt_metadata.timeout_after_ms = 0;
-#endif
 
     if( !valid )
         close();
@@ -1327,6 +1049,7 @@
     return valid;
 }
 
+
 bool CvCapture_FFMPEG::setRaw()
 {
     if (!rawMode)
@@ -1352,32 +1075,20 @@
     if (!rawModeInitialized)
     {
         rawModeInitialized = true;
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(58, 20, 100)
         CV_CODEC_ID eVideoCodec = ic->streams[video_stream]->codecpar->codec_id;
-#else
-        CV_CODEC_ID eVideoCodec = video_st->codec->codec_id;
-#endif
         const char* filterName = NULL;
-        if (eVideoCodec == CV_CODEC(CODEC_ID_H264)
-#if LIBAVCODEC_VERSION_MICRO >= 100 \
-    && LIBAVCODEC_BUILD >= CALC_FFMPEG_VERSION(57, 24, 102)  // FFmpeg 3.0
-            || eVideoCodec == CV_CODEC(CODEC_ID_H265)
-#elif LIBAVCODEC_VERSION_MICRO < 100 \
-    && LIBAVCODEC_BUILD >= CALC_FFMPEG_VERSION(55, 34, 1)  // libav v10+
-            || eVideoCodec == CV_CODEC(CODEC_ID_HEVC)
-#endif
-        )
+        if (   eVideoCodec == CV_CODEC(CODEC_ID_H264)
+            || eVideoCodec == CV_CODEC(CODEC_ID_H265))
         {
             if(h26xContainer(ic->iformat->long_name))
                 filterName = eVideoCodec == CV_CODEC(CODEC_ID_H264) ? "h264_mp4toannexb" : "hevc_mp4toannexb";
         }
         if (filterName)
         {
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(58, 20, 100)
             const AVBitStreamFilter * bsf = av_bsf_get_by_name(filterName);
             if (!bsf)
             {
-                CV_WARN(cv::format("Bitstream filter is not available: %s", filterName).c_str());
+                //fixme CV_WARN("Bitstream filter is not available: %s", filterName);
                 return false;
             }
             int err = av_bsf_alloc(bsf, &bsfc);
@@ -1393,14 +1104,6 @@
                 CV_WARN("Error initializing bitstream buffer");
                 return false;
             }
-#else
-            bsfc = av_bitstream_filter_init(filterName);
-            if (!bsfc)
-            {
-                CV_WARN(cv::format("Bitstream filter is not available: %s", filterName).c_str());
-                return false;
-            }
-#endif
         }
     }
     if (bsfc)
@@ -1410,7 +1113,6 @@
             _opencv_ffmpeg_av_packet_unref(&packet_filtered);
         }
 
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(58, 20, 100)
         int err = av_bsf_send_packet(bsfc, &packet);
         if (err < 0)
         {
@@ -1423,16 +1125,6 @@
             CV_WARN("Filtered packet retrieve failed");
             return false;
         }
-#else
-        AVCodecContext* ctx = ic->streams[video_stream]->codec;
-        int err = av_bitstream_filter_filter(bsfc, ctx, NULL, &packet_filtered.data,
-            &packet_filtered.size, packet.data, packet.size, packet_filtered.flags & AV_PKT_FLAG_KEY);
-        if (err < 0)
-        {
-            CV_WARN("Packet filtering failed");
-            return false;
-        }
-#endif
         return packet_filtered.data != NULL;
     }
     return packet.data != NULL;
@@ -1442,8 +1134,8 @@
 {
     bool valid = false;
 
-    static const size_t max_read_attempts = cv::utils::getConfigurationParameterSizeT("OPENCV_FFMPEG_READ_ATTEMPTS", 4096);
-    static const size_t max_decode_attempts = cv::utils::getConfigurationParameterSizeT("OPENCV_FFMPEG_DECODE_ATTEMPTS", 64);
+    static const size_t max_read_attempts = 4096; // cv::utils::getConfigurationParameterSizeT("OPENCV_FFMPEG_READ_ATTEMPTS", 4096);
+    static const size_t max_decode_attempts = 64; //cv::utils::getConfigurationParameterSizeT("OPENCV_FFMPEG_DECODE_ATTEMPTS", 64);
     size_t cur_read_attempts = 0;
     size_t cur_decode_attempts = 0;
 
@@ -1455,17 +1147,13 @@
 
     picture_pts = AV_NOPTS_VALUE_;
 
-#if USE_AV_INTERRUPT_CALLBACK
     // activate interrupt callback
     interrupt_metadata.timeout = 0;
     get_monotonic_time(&interrupt_metadata.value);
     interrupt_metadata.timeout_after_ms = read_timeout;
-#endif
 
-#if USE_AV_SEND_FRAME_API
     // check if we can receive frame from previously decoded packet
     valid = avcodec_receive_frame(context, picture) >= 0;
-#endif
 
     // get the next frame
     while (!valid)
@@ -1473,13 +1161,11 @@
 
         _opencv_ffmpeg_av_packet_unref (&packet);
 
-#if USE_AV_INTERRUPT_CALLBACK
         if (interrupt_metadata.timeout)
         {
             valid = false;
             break;
         }
-#endif
 
         int ret = av_read_frame(ic, &packet);
 
@@ -1519,16 +1205,11 @@
         }
 
         // Decode video frame
-#if USE_AV_SEND_FRAME_API
         if (avcodec_send_packet(context, &packet) < 0) {
             break;
         }
         ret = avcodec_receive_frame(context, picture);
-#else
-        int got_picture = 0;
-        avcodec_decode_video2(context, picture, &got_picture, &packet);
-        ret = got_picture ? 0 : -1;
-#endif
+
         if (ret >= 0) {
             valid = true;
         } else if (ret == AVERROR(EAGAIN)) {
@@ -1538,10 +1219,10 @@
         {
             if (++cur_decode_attempts > max_decode_attempts)
             {
-                CV_LOG_WARNING(NULL,
+                fprintf(stderr,
                     "frame decode max attempts exceeded, try to increase attempt "
                     "limit by setting environment variable OPENCV_FFMPEG_DECODE_ATTEMPTS "
-                    "(current value is " << max_decode_attempts << ")");
+                    "(current value is %zu)\n", max_decode_attempts);
                 break;
             }
         }
@@ -1556,10 +1237,8 @@
     if (!rawMode && valid && first_frame_number < 0)
         first_frame_number = dts_to_frame_number(picture_pts);
 
-#if USE_AV_INTERRUPT_CALLBACK
     // deactivate interrupt callback
     interrupt_metadata.timeout_after_ms = 0;
-#endif
 
     // return if we have a new frame or not
     return valid;
@@ -1580,8 +1259,8 @@
             ret = p.data != NULL;
         }
         else if (flag == extraDataIdx) {
-            *data = ic->streams[video_stream]->CV_FFMPEG_CODEC_FIELD->extradata;
-            *step = ic->streams[video_stream]->CV_FFMPEG_CODEC_FIELD->extradata_size;
+            *data = ic->streams[video_stream]->codecpar->extradata;
+            *step = ic->streams[video_stream]->codecpar->extradata_size;
         }
         *width = *step;
         *height = 1;
@@ -1591,17 +1270,6 @@
     }
 
     AVFrame* sw_picture = picture;
-#if USE_AV_HW_CODECS
-    // if hardware frame, copy it to system memory
-    if (picture && picture->hw_frames_ctx) {
-        sw_picture = av_frame_alloc();
-        //if (av_hwframe_map(sw_picture, picture, AV_HWFRAME_MAP_READ) < 0) {
-        if (av_hwframe_transfer_data(sw_picture, picture, 0) < 0) {
-            CV_LOG_ERROR(NULL, "Error copying data from GPU to CPU (av_hwframe_transfer_data)");
-            return false;
-        }
-    }
-#endif
 
     if (!sw_picture || !sw_picture->data[0])
         return false;
@@ -1622,8 +1290,8 @@
     }
 
     if( img_convert_ctx == NULL ||
-        frame.width != video_st->CV_FFMPEG_CODEC_FIELD->width ||
-        frame.height != video_st->CV_FFMPEG_CODEC_FIELD->height ||
+        frame.width != video_st->codecpar->width ||
+        frame.height != video_st->codecpar->height ||
         frame.data == NULL )
     {
         // Some sws_scale optimizations have some assumptions about alignment of data/step/width/height
@@ -1643,7 +1311,6 @@
         if (img_convert_ctx == NULL)
             return false;//CV_Error(0, "Cannot initialize the conversion context!");
 
-#if USE_AV_FRAME_GET_BUFFER
         av_frame_unref(&rgb_picture);
         rgb_picture.format = result_format;
         rgb_picture.width = buffer_width;
@@ -1653,17 +1320,8 @@
             CV_WARN("OutOfMemory");
             return false;
         }
-#else
-        int aligns[AV_NUM_DATA_POINTERS];
-        avcodec_align_dimensions2(video_st->codec, &buffer_width, &buffer_height, aligns);
-        rgb_picture.data[0] = (uint8_t*)realloc(rgb_picture.data[0],
-                _opencv_ffmpeg_av_image_get_buffer_size( result_format,
-                                    buffer_width, buffer_height ));
-        _opencv_ffmpeg_av_image_fill_arrays(&rgb_picture, rgb_picture.data[0],
-                        result_format, buffer_width, buffer_height );
-#endif
-        frame.width = video_st->CV_FFMPEG_CODEC_FIELD->width;
-        frame.height = video_st->CV_FFMPEG_CODEC_FIELD->height;
+        frame.width = video_st->codecpar->width;
+        frame.height = video_st->codecpar->height;
         frame.data = rgb_picture.data[0];
         frame.step = rgb_picture.linesize[0];
     }
@@ -1682,43 +1340,13 @@
     *width = frame.width;
     *height = frame.height;
 
-#if USE_AV_HW_CODECS
-    if (sw_picture != picture)
-    {
-        av_frame_free(&sw_picture);
-    }
-#endif
     return true;
 }
 
-bool CvCapture_FFMPEG::retrieveHWFrame(cv::OutputArray output)
-{
-#if USE_AV_HW_CODECS
-    // check that we have HW frame in GPU memory
-    if (!picture || !picture->hw_frames_ctx || !context) {
-        return false;
-    }
-
-    // GPU color conversion NV12->BGRA, from GPU media buffer to GPU OpenCL buffer
-    return hw_copy_frame_to_umat(context->hw_device_ctx, picture, output);
-#else
-    CV_UNUSED(output);
-    return false;
-#endif
-}
-
 static inline double getCodecTag(const AVCodecID codec_id) {
     const struct AVCodecTag* fallback_tags[] = {
-        // APIchanges:
-        // 2012-01-31 - dd6d3b0 - lavf 54.01.0
-        //   Add avformat_get_riff_video_tags() and avformat_get_riff_audio_tags().
         avformat_get_riff_video_tags(),
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(55, 25, 100) && defined LIBAVFORMAT_VERSION_MICRO && LIBAVFORMAT_VERSION_MICRO >= 100
-        // APIchanges: ffmpeg only
-        // 2014-01-19 - 1a193c4 - lavf 55.25.100 - avformat.h
-        //   Add avformat_get_mov_video_tags() and avformat_get_mov_audio_tags().
         avformat_get_mov_video_tags(),
-#endif
         codec_bmp_tags, // fallback for avformat < 54.1
         NULL };
     return av_codec_get_tag(fallback_tags, codec_id);
@@ -1732,7 +1360,7 @@
         return getCodecTag(codec_id);
     return (double)CV_FOURCC(codec_fourcc[0], codec_fourcc[1], codec_fourcc[2], codec_fourcc[3]);
 }
-
+#if 0
 double CvCapture_FFMPEG::getProperty( int property_id ) const
 {
     if( !video_st || !context ) return 0;
@@ -1760,9 +1388,9 @@
     case CAP_PROP_FPS:
         return get_fps();
     case CAP_PROP_FOURCC: {
-        const double fourcc = getCodecIdFourcc(video_st->CV_FFMPEG_CODEC_FIELD->codec_id);
+        const double fourcc = getCodecIdFourcc(video_st->codecpar->codec_id);
         if (fourcc != -1) return fourcc;
-        const double codec_tag = (double)video_st->CV_FFMPEG_CODEC_FIELD->codec_tag;
+        const double codec_tag = (double)video_st->codecpar->codec_tag;
         if (codec_tag) return codec_tag;
         else return -1;
     }
@@ -1772,11 +1400,7 @@
         return _opencv_ffmpeg_get_sample_aspect_ratio(ic->streams[video_stream]).den;
     case CAP_PROP_CODEC_PIXEL_FORMAT:
     {
-#ifdef CV_FFMPEG_CODECPAR
         AVPixelFormat pix_fmt = (AVPixelFormat)video_st->codecpar->format;
-#else
-        AVPixelFormat pix_fmt = video_st->codec->pix_fmt;
-#endif
         unsigned int fourcc_tag = avcodec_pix_fmt_to_codec_tag(pix_fmt);
         return (fourcc_tag == 0) ? (double)-1 : (double)fourcc_tag;
     }
@@ -1797,19 +1421,7 @@
     case CAP_PROP_ORIENTATION_META:
         return static_cast<double>(rotation_angle);
     case CAP_PROP_ORIENTATION_AUTO:
-#if LIBAVUTIL_BUILD >= CALC_FFMPEG_VERSION(52, 94, 100)
         return static_cast<double>(rotation_auto);
-#else
-        return 0;
-#endif
-#if USE_AV_HW_CODECS
-    case CAP_PROP_HW_ACCELERATION:
-        return static_cast<double>(va_type);
-    case CAP_PROP_HW_DEVICE:
-        return static_cast<double>(hw_device);
-    case CAP_PROP_HW_ACCELERATION_USE_OPENCL:
-        return static_cast<double>(use_opencl);
-#endif  // USE_AV_HW_CODECS
     case CAP_PROP_STREAM_OPEN_TIME_USEC:
         //ic->start_time_realtime is in microseconds
         return ((double)ic->start_time_realtime);
@@ -1821,6 +1433,7 @@
 
     return 0;
 }
+#endif
 
 double CvCapture_FFMPEG::r2d(AVRational r) const
 {
@@ -1846,23 +1459,7 @@
 
 double CvCapture_FFMPEG::get_fps() const
 {
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(55, 1, 100) && LIBAVFORMAT_VERSION_MICRO >= 100
     double fps = r2d(av_guess_frame_rate(ic, ic->streams[video_stream], NULL));
-#else
-    double fps = r2d(ic->streams[video_stream]->avg_frame_rate);
-
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(52, 111, 0)
-    if (fps < eps_zero)
-    {
-        fps = r2d(ic->streams[video_stream]->avg_frame_rate);
-    }
-#endif
-
-    if (fps < eps_zero)
-    {
-        fps = 1.0 / r2d(ic->streams[video_stream]->time_base);
-    }
-#endif
     return fps;
 }
 
@@ -1892,20 +1489,14 @@
 void CvCapture_FFMPEG::get_rotation_angle()
 {
     rotation_angle = 0;
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(57, 68, 100)
     const uint8_t *data = 0;
     data = av_stream_get_side_data(video_st, AV_PKT_DATA_DISPLAYMATRIX, NULL);
     if (data)
     {
-        rotation_angle = -cvRound(av_display_rotation_get((const int32_t*)data));
+        rotation_angle = -round(av_display_rotation_get((const int32_t*)data));
         if (rotation_angle < 0)
             rotation_angle += 360;
     }
-#elif LIBAVUTIL_BUILD >= CALC_FFMPEG_VERSION(52, 94, 100)
-    AVDictionaryEntry *rotate_tag = av_dict_get(video_st->metadata, "rotate", NULL, 0);
-    if (rotate_tag != NULL)
-        rotation_angle = atoi(rotate_tag->value);
-#endif
 }
 
 void CvCapture_FFMPEG::seek(int64_t _frame_number)
@@ -1975,7 +1566,7 @@
 bool CvCapture_FFMPEG::setProperty( int property_id, double value )
 {
     if( !video_st ) return false;
-
+#if 0
     switch( property_id )
     {
     case CAP_PROP_POS_MSEC:
@@ -2008,29 +1599,27 @@
         convertRGB = (value != 0);
         return true;
     case CAP_PROP_ORIENTATION_AUTO:
-#if LIBAVUTIL_BUILD >= CALC_FFMPEG_VERSION(52, 94, 100)
         rotation_auto = value != 0 ? true : false;
         return true;
-#else
-        rotation_auto = false;
-        return false;
-#endif
     default:
         return false;
     }
-
+#endif
     return true;
 }
 
-
 ///////////////// FFMPEG CvVideoWriter implementation //////////////////////////
-struct CvVideoWriter_FFMPEG
+static bool writer_type_loaded = false;
+
+class CvVideoWriter_FFMPEG: public octave_base_value
 {
+  public:
+    CvVideoWriter_FFMPEG ();
+
     bool open( const char* filename, int fourcc,
-               double fps, int width, int height, const VideoWriterParameters& params );
+               double fps, int width, int height, bool isColor );
     void close();
     bool writeFrame( const unsigned char* data, int step, int width, int height, int cn, int origin );
-    bool writeHWFrame(cv::InputArray input);
     double getProperty(int propId) const;
 
     void init();
@@ -2052,11 +1641,42 @@
     int               frame_idx;
     bool              ok;
     struct SwsContext *img_convert_ctx;
-    VideoAccelerationType va_type;
     int               hw_device;
     int               use_opencl;
+
+    const char* get_video_codec_name () const
+    {
+      return _opencv_avcodec_get_name(video_st->codecpar->codec_id);
+    }
+
+    bool is_constant (void) const
+    {
+      return true;
+    }
+    bool is_defined (void) const
+    {
+      return true;
+    }
+
+    DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+
+    void print (std::ostream & os, bool pr_as_read_syntax = false)
+    {
+      os << "CvVideoWriter_FFMPEG:" << std::endl;
+      os << "  ok                      = " << ok << std::endl;
+      os << "  frame_width             = " << frame_width << std::endl;
+      os << "  frame_height            = " << frame_height << std::endl;
+      os << "  frame_idx               = " << frame_idx << std::endl;
+
+    // FIXME: add more properties
+    }
 };
 
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(CvVideoWriter_FFMPEG, "CvVideoWriter_FFMPEG", "CvVideoWriter_FFMPEG");
+
+CvVideoWriter_FFMPEG::CvVideoWriter_FFMPEG ()
+  : octave_base_value () { init (); };
+
 static const char * icvFFMPEGErrStr(int err)
 {
     switch(err) {
@@ -2116,7 +1736,6 @@
     img_convert_ctx = 0;
     frame_width = frame_height = 0;
     frame_idx = 0;
-    va_type = VIDEO_ACCELERATION_NONE;
     hw_device = -1;
     use_opencl = 0;
     ok = false;
@@ -2132,12 +1751,7 @@
     uint8_t * picture_buf = 0;
     int size;
 
-#if LIBAVCODEC_BUILD >= (LIBAVCODEC_VERSION_MICRO >= 100 \
-    ? CALC_FFMPEG_VERSION(55, 45, 101) : CALC_FFMPEG_VERSION(55, 28, 1))
     picture = av_frame_alloc();
-#else
-    picture = avcodec_alloc_frame();
-#endif
     if (!picture)
         return NULL;
 
@@ -2167,27 +1781,16 @@
                                                    int w, int h, int bitrate,
                                                    double fps, AVPixelFormat pixel_format, int fourcc)
 {
-#ifdef CV_FFMPEG_CODECPAR
     AVCodecContext *c = avcodec_alloc_context3(codec);
-#else
-    AVCodecContext *c = st->codec;
-#endif
     CV_Assert(c);
 
     int frame_rate, frame_rate_base;
 
+    CV_Assert (codec);
     c->codec_id = codec->id;
     c->codec_type = AVMEDIA_TYPE_VIDEO;
     c->codec_tag = fourcc;
 
-#ifndef CV_FFMPEG_CODECPAR
-    // Set per-codec defaults
-    CV_CODEC_ID c_id = c->codec_id;
-    avcodec_get_context_defaults3(c, codec);
-    // avcodec_get_context_defaults3 erases codec_id for some reason
-    c->codec_id = c_id;
-#endif
-
     /* put sample parameters */
     int64_t lbit_rate = (int64_t)bitrate;
     lbit_rate += (bitrate / 2);
@@ -2215,7 +1818,7 @@
     c->time_base.den = frame_rate;
     c->time_base.num = frame_rate_base;
     /* adjust time base for supported framerates */
-    if(codec && codec->supported_framerates){
+    if(codec->supported_framerates){
         const AVRational *p= codec->supported_framerates;
         AVRational req = {frame_rate, frame_rate_base};
         const AVRational *best=NULL;
@@ -2230,9 +1833,7 @@
         }
         if (best == NULL)
         {
-#ifdef CV_FFMPEG_CODECPAR
             avcodec_free_context(&c);
-#endif
             return NULL;
         }
         c->time_base.den= best->num;
@@ -2266,20 +1867,10 @@
 
     // some formats want stream headers to be separate
     if(oc->oformat->flags & AVFMT_GLOBALHEADER)
-    {
-        // flags were renamed: https://github.com/libav/libav/commit/7c6eb0a1b7bf1aac7f033a7ec6d8cacc3b5c2615
-#if LIBAVCODEC_BUILD >= (LIBAVCODEC_VERSION_MICRO >= 100 \
-     ? CALC_FFMPEG_VERSION(56, 60, 100) : CALC_FFMPEG_VERSION(56, 35, 0))
-        c->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
-#else
-        c->flags |= CODEC_FLAG_GLOBAL_HEADER;
-#endif
-    }
+      c->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
 
     st->avg_frame_rate = av_make_q(frame_rate, frame_rate_base);
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(55, 20, 0)
     st->time_base = c->time_base;
-#endif
 
     return c;
 }
@@ -2291,33 +1882,14 @@
                                       AVFrame * picture, int frame_idx)
 {
     int ret = OPENCV_NO_FRAMES_WRITTEN_CODE;
-
-#if LIBAVFORMAT_BUILD < CALC_FFMPEG_VERSION(57, 0, 0)
-    if (oc->oformat->flags & AVFMT_RAWPICTURE)
-    {
-        /* raw video case. The API will change slightly in the near
-           futur for that */
-        AVPacket pkt;
-        av_init_packet(&pkt);
-
-        pkt.flags |= PKT_FLAG_KEY;
-        pkt.stream_index= video_st->index;
-        pkt.data= (uint8_t *)picture;
-        pkt.size= sizeof(AVPicture);
-
-        ret = av_write_frame(oc, &pkt);
-    }
-    else
-#endif
     {
         /* encode the image */
-#if USE_AV_SEND_FRAME_API
         if (picture == NULL && frame_idx == 0) {
             ret = 0;
         } else {
             ret = avcodec_send_frame(c, picture);
             if (ret < 0)
-                CV_LOG_ERROR(NULL, "Error sending frame to encoder (avcodec_send_frame)");
+                fprintf (stderr, "Error sending frame to encoder (avcodec_send_frame)");
         }
         while (ret >= 0)
         {
@@ -2325,7 +1897,9 @@
             pkt->stream_index = video_st->index;
             ret = avcodec_receive_packet(c, pkt);
 
-            if(!ret)
+			//fprintf (stderr, "USE_AV_SEND_FRAME_API avcodec_receive_packet returned %i\n", ret);
+
+            if (!ret)
             {
                 av_packet_rescale_ts(pkt, c->time_base, video_st->time_base);
                 ret = av_write_frame(oc, pkt);
@@ -2333,33 +1907,17 @@
                 continue;
             }
 
+			// FIXME von Andy: mir scheint bei der USE_AV_SEND_FRAME_API
+			// ist das okay, wenn ein EAGAIN zurück kommt
+			if (ret == AVERROR(EAGAIN))
+			{
+				//fprintf (stderr, "von Andy, Rückgabe von avcodec_receive_packet umbiegen...\n");
+				ret = 0;
+			}
+
             av_packet_free(&pkt);
             break;
         }
-#else
-        CV_UNUSED(frame_idx);
-        AVPacket pkt;
-        av_init_packet(&pkt);
-        int got_output = 0;
-        pkt.data = NULL;
-        pkt.size = 0;
-        ret = avcodec_encode_video2(c, &pkt, picture, &got_output);
-        if (ret < 0)
-            ;
-        else if (got_output) {
-            if (pkt.pts != (int64_t)AV_NOPTS_VALUE)
-                pkt.pts = av_rescale_q(pkt.pts, c->time_base, video_st->time_base);
-            if (pkt.dts != (int64_t)AV_NOPTS_VALUE)
-                pkt.dts = av_rescale_q(pkt.dts, c->time_base, video_st->time_base);
-            if (pkt.duration)
-                pkt.duration = av_rescale_q(pkt.duration, c->time_base, video_st->time_base);
-            pkt.stream_index= video_st->index;
-            ret = av_write_frame(oc, &pkt);
-            _opencv_ffmpeg_av_packet_unref(&pkt);
-        }
-        else
-            ret = OPENCV_NO_FRAMES_WRITTEN_CODE;
-#endif
     }
     return ret;
 }
@@ -2427,10 +1985,6 @@
     }
 
     AVPixelFormat sw_pix_fmt = context->pix_fmt;
-#if USE_AV_HW_CODECS
-    if (context->hw_frames_ctx)
-        sw_pix_fmt = ((AVHWFramesContext*)context->hw_frames_ctx->data)->sw_format;
-#endif
     if ( sw_pix_fmt != input_pix_fmt ) {
         CV_Assert( input_picture );
         // let input_picture point to the raw data buffer of 'image'
@@ -2465,30 +2019,6 @@
     }
 
     bool ret;
-#if USE_AV_HW_CODECS
-    if (context->hw_device_ctx) {
-        // copy data to HW frame
-        AVFrame* hw_frame = av_frame_alloc();
-        if (!hw_frame) {
-            CV_LOG_ERROR(NULL, "Error allocating AVFrame (av_frame_alloc)");
-            return false;
-        }
-        if (av_hwframe_get_buffer(context->hw_frames_ctx, hw_frame, 0) < 0) {
-            CV_LOG_ERROR(NULL, "Error obtaining HW frame (av_hwframe_get_buffer)");
-            av_frame_free(&hw_frame);
-            return false;
-        }
-        if (av_hwframe_transfer_data(hw_frame, picture, 0) < 0) {
-            CV_LOG_ERROR(NULL, "Error copying data from CPU to GPU (av_hwframe_transfer_data)");
-            av_frame_free(&hw_frame);
-            return false;
-        }
-        hw_frame->pts = frame_idx;
-        int ret_write = icv_av_write_frame_FFMPEG(oc, video_st, context, outbuf, outbuf_size, hw_frame, frame_idx);
-        ret = ret_write >= 0 ? true : false;
-        av_frame_free(&hw_frame);
-    } else
-#endif
     {
         picture->pts = frame_idx;
         int ret_write = icv_av_write_frame_FFMPEG(oc, video_st, context, outbuf, outbuf_size, picture, frame_idx);
@@ -2500,61 +2030,6 @@
     return ret;
 }
 
-bool CvVideoWriter_FFMPEG::writeHWFrame(cv::InputArray input) {
-#if USE_AV_HW_CODECS
-    if (!video_st || !context || !context->hw_frames_ctx || !context->hw_device_ctx)
-        return false;
-
-    // Get hardware frame from frame pool
-    AVFrame* hw_frame = av_frame_alloc();
-    if (!hw_frame) {
-        return false;
-    }
-    if (av_hwframe_get_buffer(context->hw_frames_ctx, hw_frame, 0) < 0) {
-        av_frame_free(&hw_frame);
-        return false;
-    }
-
-    // GPU to GPU copy
-    if (!hw_copy_umat_to_frame(context->hw_device_ctx, input, hw_frame)) {
-        av_frame_free(&hw_frame);
-        return false;
-    }
-
-    // encode
-    hw_frame->pts = frame_idx;
-    icv_av_write_frame_FFMPEG( oc, video_st, context, outbuf, outbuf_size, hw_frame, frame_idx);
-    frame_idx++;
-
-    av_frame_free(&hw_frame);
-
-    return true;
-#else
-    CV_UNUSED(input);
-    return false;
-#endif
-}
-
-double CvVideoWriter_FFMPEG::getProperty(int propId) const
-{
-    CV_UNUSED(propId);
-#if USE_AV_HW_CODECS
-    if (propId == VIDEOWRITER_PROP_HW_ACCELERATION)
-    {
-        return static_cast<double>(va_type);
-    }
-    else if (propId == VIDEOWRITER_PROP_HW_DEVICE)
-    {
-        return static_cast<double>(hw_device);
-    }
-    else if (propId == VIDEOWRITER_PROP_HW_ACCELERATION_USE_OPENCL)
-    {
-        return static_cast<double>(use_opencl);
-    }
-#endif
-    return 0;
-}
-
 /// close video output stream and free associated memory
 void CvVideoWriter_FFMPEG::close()
 {
@@ -2566,17 +2041,12 @@
     /* write the trailer, if any */
     if (picture && ok && oc)
     {
-#if LIBAVFORMAT_BUILD < CALC_FFMPEG_VERSION(57, 0, 0)
-        if (!(oc->oformat->flags & AVFMT_RAWPICTURE))
-#endif
-        {
-            for(;;)
-            {
-                int ret = icv_av_write_frame_FFMPEG( oc, video_st, context, outbuf, outbuf_size, NULL, frame_idx);
-                if( ret == OPENCV_NO_FRAMES_WRITTEN_CODE || ret < 0 )
-                    break;
-            }
-        }
+		for(;;)
+		{
+			int ret = icv_av_write_frame_FFMPEG( oc, video_st, context, outbuf, outbuf_size, NULL, frame_idx);
+			if( ret == OPENCV_NO_FRAMES_WRITTEN_CODE || ret < 0 )
+				break;
+		}
         av_write_trailer(oc);
     }
 
@@ -2598,14 +2068,7 @@
     if (input_picture)
         av_free(input_picture);
 
-#ifdef CV_FFMPEG_CODECPAR
     avcodec_free_context(&context);
-#else
-    /* close codec */
-    if (context)  // fixed after https://github.com/FFmpeg/FFmpeg/commit/3e1f507f3e8f16b716aa115552d243b48ae809bd
-        avcodec_close(context);
-    context = NULL;
-#endif
 
     av_free(outbuf);
 
@@ -2668,14 +2131,12 @@
 
 /// Create a video writer object that uses FFMPEG
 bool CvVideoWriter_FFMPEG::open( const char * filename, int fourcc,
-                                 double fps, int width, int height, const VideoWriterParameters& params)
+                                 double fps, int width, int height, bool is_color)
 {
     const bool threadSafe = isThreadSafe();
     InternalFFMpegRegister::init(threadSafe);
 
-    std::unique_lock<cv::Mutex> lock(_mutex, std::defer_lock);
-    if (!threadSafe)
-        lock.lock();
+	AutoLock lock(_mutex);
 
     CV_CODEC_ID codec_id = CV_CODEC(CODEC_ID_NONE);
     AVPixelFormat codec_pix_fmt;
@@ -2683,8 +2144,8 @@
 
     close();
 
-    const bool is_color = params.get(VIDEOWRITER_PROP_IS_COLOR, true);
-    const int depth = params.get(VIDEOWRITER_PROP_DEPTH, CV_8U);
+	// AW: original params.get(VIDEOWRITER_PROP_DEPTH, CV_8U);
+    const int depth = CV_8U;
     const bool is_supported = depth == CV_8U || (depth == CV_16U && !is_color);
     if (!is_supported)
     {
@@ -2692,40 +2153,6 @@
                              "only CV_8UC1/CV_8UC3/CV_16UC1 are supported.");
         return false;
     }
-    if (params.has(VIDEOWRITER_PROP_HW_ACCELERATION))
-    {
-        va_type = params.get<VideoAccelerationType>(VIDEOWRITER_PROP_HW_ACCELERATION, VIDEO_ACCELERATION_NONE);
-#if !USE_AV_HW_CODECS
-        if (va_type != VIDEO_ACCELERATION_NONE && va_type != VIDEO_ACCELERATION_ANY)
-        {
-            CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: FFmpeg backend is build without acceleration support. Can't handle VIDEOWRITER_PROP_HW_ACCELERATION parameter. Bailout");
-            return false;
-        }
-#endif
-    }
-    if (params.has(VIDEOWRITER_PROP_HW_DEVICE))
-    {
-        hw_device = params.get<int>(VIDEOWRITER_PROP_HW_DEVICE, -1);
-        if (va_type == VIDEO_ACCELERATION_NONE && hw_device != -1)
-        {
-            CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: Invalid usage of VIDEOWRITER_PROP_HW_DEVICE without requested H/W acceleration. Bailout");
-            return false;
-        }
-        if (va_type == VIDEO_ACCELERATION_ANY && hw_device != -1)
-        {
-            CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: Invalid usage of VIDEOWRITER_PROP_HW_DEVICE with 'ANY' H/W acceleration. Bailout");
-            return false;
-        }
-    }
-    if (params.has(VIDEOWRITER_PROP_HW_ACCELERATION_USE_OPENCL)) {
-        use_opencl = params.get<int>(VIDEOWRITER_PROP_HW_ACCELERATION_USE_OPENCL);
-    }
-
-    if (params.warnUnusedParameters())
-    {
-        CV_LOG_ERROR(NULL, "VIDEOIO/FFMPEG: unsupported parameters in VideoWriter, see logger INFO channel for details");
-        return false;
-    }
 
     // check arguments
     if( !filename )
@@ -2783,16 +2210,8 @@
     if( (codec_id = av_codec_get_id(fmt->codec_tag, fourcc)) == CV_CODEC(CODEC_ID_NONE) )
     {
         const struct AVCodecTag * fallback_tags[] = {
-// APIchanges:
-// 2012-01-31 - dd6d3b0 - lavf 54.01.0
-//   Add avformat_get_riff_video_tags() and avformat_get_riff_audio_tags().
                 avformat_get_riff_video_tags(),
-#if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(55, 25, 100) && defined LIBAVFORMAT_VERSION_MICRO && LIBAVFORMAT_VERSION_MICRO >= 100
-// APIchanges: ffmpeg only
-// 2014-01-19 - 1a193c4 - lavf 55.25.100 - avformat.h
-//   Add avformat_get_mov_video_tags() and avformat_get_mov_audio_tags().
                 avformat_get_mov_video_tags(),
-#endif
                 codec_bmp_tags, // fallback for avformat < 54.1
                 NULL };
         if (codec_id == CV_CODEC(CODEC_ID_NONE)) {
@@ -2839,15 +2258,12 @@
 
     /* set file name */
     oc->oformat = fmt;
-#ifndef CV_FFMPEG_URL
-    snprintf(oc->filename, sizeof(oc->filename), "%s", filename);
-#else
     size_t name_len = strlen(filename);
     oc->url = (char*)av_malloc(name_len + 1);
     CV_Assert(oc->url);
     memcpy((void*)oc->url, filename, name_len + 1);
     oc->url[name_len] = '\0';
-#endif
+
     /* set some options */
     oc->max_delay = (int)(0.7*AV_TIME_BASE);  /* This reduces buffer underrun warnings with MPEG */
 
@@ -2985,33 +2401,7 @@
     // find and open encoder, try HW acceleration types specified in 'hw_acceleration' list (in order)
     int err = -1;
     const AVCodec* codec = NULL;
-#if USE_AV_HW_CODECS
-    AVBufferRef* hw_device_ctx = NULL;
-    HWAccelIterator accel_iter(va_type, true/*isEncoder*/, dict);
-    while (accel_iter.good())
-    {
-#else
     do {
-#endif
-#if USE_AV_HW_CODECS
-        accel_iter.parse_next();
-        AVHWDeviceType hw_type = accel_iter.hw_type();
-        codec = NULL;
-        AVPixelFormat hw_format = AV_PIX_FMT_NONE;
-        if (hw_device_ctx)
-            av_buffer_unref(&hw_device_ctx);
-        if (hw_type != AV_HWDEVICE_TYPE_NONE)
-        {
-            codec = hw_find_codec(codec_id, hw_type, av_codec_is_encoder, accel_iter.disabled_codecs().c_str(), &hw_format);
-            if (!codec)
-                continue;
-
-            hw_device_ctx = hw_create_device(hw_type, hw_device, accel_iter.device_subname(), use_opencl != 0);
-            if (!hw_device_ctx)
-                continue;
-        }
-        else if (hw_type == AV_HWDEVICE_TYPE_NONE)
-#endif
         {
             codec = avcodec_find_encoder(codec_id);
             if (!codec) {
@@ -3021,15 +2411,9 @@
         }
         if (!codec)
             continue;
-#if USE_AV_HW_CODECS
-        AVPixelFormat format = (hw_format != AV_PIX_FMT_NONE) ? hw_format : codec_pix_fmt;
-#else
         AVPixelFormat format = codec_pix_fmt;
-#endif
 
-#ifdef CV_FFMPEG_CODECPAR
         avcodec_free_context(&context);
-#endif
         context = icv_configure_video_stream_FFMPEG(oc, video_st, codec,
                                               width, height, (int) (bitrate + 0.5),
                                               fps, format, fourcc);
@@ -3046,17 +2430,6 @@
 #endif
 #endif
 
-#if USE_AV_HW_CODECS
-        if (hw_device_ctx) {
-            context->hw_device_ctx = av_buffer_ref(hw_device_ctx);
-            if (hw_format != AV_PIX_FMT_NONE) {
-                context->hw_frames_ctx = hw_create_frames(NULL, hw_device_ctx, width, height, hw_format);
-                if (!context->hw_frames_ctx)
-                    continue;
-            }
-        }
-#endif
-
         int64_t lbit_rate = (int64_t) context->bit_rate;
         lbit_rate += (int64_t)(bitrate / 2);
         lbit_rate = std::min(lbit_rate, (int64_t) INT_MAX);
@@ -3066,25 +2439,11 @@
         /* open the codec */
         err = avcodec_open2(context, codec, NULL);
         if (err >= 0) {
-#if USE_AV_HW_CODECS
-            va_type = hw_type_to_va_type(hw_type);
-            if (hw_type != AV_HWDEVICE_TYPE_NONE && hw_device < 0)
-                hw_device = 0;
-#endif
             break;
         } else {
             CV_LOG_ERROR(NULL, "Could not open codec " << codec->name << ", error: " << icvFFMPEGErrStr(err) << " (" << err << ")");
         }
-#if USE_AV_HW_CODECS
-    }  // while (accel_iter.good())
-#else
     } while (0);
-#endif
-
-#if USE_AV_HW_CODECS
-    if (hw_device_ctx)
-        av_buffer_unref(&hw_device_ctx);
-#endif
 
     if (dict != NULL)
         av_dict_free(&dict);
@@ -3094,31 +2453,17 @@
         return false;
     }
 
-#ifdef CV_FFMPEG_CODECPAR
     // Copy all to codecpar...
     // !!! https://stackoverflow.com/questions/15897849/c-ffmpeg-not-writing-avcc-box-information
     avcodec_parameters_from_context(video_st->codecpar, context);
-#endif
-
-    outbuf = NULL;
 
-
-#if LIBAVFORMAT_BUILD < CALC_FFMPEG_VERSION(57, 0, 0)
-    if (!(oc->oformat->flags & AVFMT_RAWPICTURE))
-#endif
-    {
-        /* allocate output buffer */
-        /* assume we will never get codec output with more than 4 bytes per pixel... */
-        outbuf_size = width*height*4;
-        outbuf = (uint8_t *) av_malloc(outbuf_size);
-    }
+	/* allocate output buffer */
+	/* assume we will never get codec output with more than 4 bytes per pixel... */
+	outbuf_size = width*height*4;
+	outbuf = (uint8_t *) av_malloc(outbuf_size);
 
     bool need_color_convert;
     AVPixelFormat sw_pix_fmt = context->pix_fmt;
-#if USE_AV_HW_CODECS
-    if (context->hw_frames_ctx)
-        sw_pix_fmt = ((AVHWFramesContext*)context->hw_frames_ctx->data)->sw_format;
-#endif
 
     need_color_convert = (sw_pix_fmt != input_pix_fmt);
 
@@ -3149,9 +2494,9 @@
     }
 
     /* write the stream header, if any */
-    err=avformat_write_header(oc, NULL);
+    global_err=avformat_write_header(oc, NULL);
 
-    if(err < 0)
+    if(global_err < 0)
     {
         close();
         remove(filename);
@@ -3166,7 +2511,7 @@
 }
 
 
-
+/*
 static
 CvCapture_FFMPEG* cvCreateFileCaptureWithParams_FFMPEG(const char* filename, const VideoCaptureParameters& params)
 {
@@ -3192,22 +2537,24 @@
         *capture = 0;
     }
 }
+*/
 
 int cvSetCaptureProperty_FFMPEG(CvCapture_FFMPEG* capture, int prop_id, double value)
 {
     return capture->setProperty(prop_id, value);
 }
 
-double cvGetCaptureProperty_FFMPEG(CvCapture_FFMPEG* capture, int prop_id)
-{
-    return capture->getProperty(prop_id);
-}
+//double cvGetCaptureProperty_FFMPEG(CvCapture_FFMPEG* capture, int prop_id)
+//{
+//    return capture->getProperty(prop_id);
+//}
 
 int cvGrabFrame_FFMPEG(CvCapture_FFMPEG* capture)
 {
     return capture->grabFrame();
 }
 
+/* Original, was hat man sich da gedacht?
 int cvRetrieveFrame_FFMPEG(CvCapture_FFMPEG* capture, unsigned char** data, int* step, int* width, int* height, int* cn)
 {
     int depth = CV_8U;
@@ -3218,29 +2565,29 @@
 {
     return capture->retrieveFrame(0, data, step, width, height, cn, depth);
 }
+*/
+
+/*
+int cvRetrieveFrame_FFMPEG(CvCapture_FFMPEG* capture, unsigned char** data, int* step, int* width, int* height, int* cn, int* depth)
+{
+    return capture->retrieveFrame(0, data, step, width, height, cn, depth);
+}
+*/
 
-static CvVideoWriter_FFMPEG* cvCreateVideoWriterWithParams_FFMPEG( const char* filename, int fourcc, double fps,
-                                                  int width, int height, const VideoWriterParameters& params )
+CvVideoWriter_FFMPEG* cvCreateVideoWriter_FFMPEG( const char* filename, int fourcc, double fps,
+                                                  int width, int height, int isColor )
 {
     CvVideoWriter_FFMPEG* writer = (CvVideoWriter_FFMPEG*)malloc(sizeof(*writer));
     if (!writer)
         return 0;
     writer->init();
-    if( writer->open( filename, fourcc, fps, width, height, params ))
+    if( writer->open( filename, fourcc, fps, width, height, isColor != 0 ))
         return writer;
     writer->close();
     free(writer);
     return 0;
 }
 
-CvVideoWriter_FFMPEG* cvCreateVideoWriter_FFMPEG( const char* filename, int fourcc, double fps,
-                                                  int width, int height, int isColor )
-{
-    VideoWriterParameters params;
-    params.add(VIDEOWRITER_PROP_IS_COLOR, isColor);
-    return cvCreateVideoWriterWithParams_FFMPEG(filename, fourcc, fps, width, height, params);
-}
-
 void cvReleaseVideoWriter_FFMPEG( CvVideoWriter_FFMPEG** writer )
 {
     if( writer && *writer )
