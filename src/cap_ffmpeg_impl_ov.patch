--- cap_ffmpeg_impl.hpp	2019-03-02 17:37:08.132065054 +0100
+++ cap_ffmpeg_impl_ov.hpp	2019-03-03 20:34:30.140494395 +0100
@@ -40,14 +40,24 @@
 //
 //M*/
 
-#include "cap_ffmpeg_api.hpp"
-#if !(defined(_WIN32) || defined(WINCE))
-# include <pthread.h>
-#endif
+/* ATTENTION:
+ *
+ * This file was generated from
+ *
+ * https://github.com/opencv/opencv/blob/master/modules/videoio/src/cap_ffmpeg_impl.hpp
+ * commit 9702987209a9a17ee2d0626c535d2b7bbc6ba1bc
+ *
+ * and applying the patches in cap_ffmpeg_impl_ov.patch
+ */
+
 #include <assert.h>
 #include <algorithm>
 #include <limits>
 
+#include <string>
+#include <octave/oct.h>
+#undef USE_AV_INTERRUPT_CALLBACK
+
 #ifndef __OPENCV_BUILD
 #define CV_FOURCC(c1, c2, c3, c4) (((c1) & 255) + (((c2) & 255) << 8) + (((c3) & 255) << 16) + (((c4) & 255) << 24))
 #endif
@@ -472,9 +482,13 @@
 #endif
 }
 
+static bool capture_type_loaded = false;
 
-struct CvCapture_FFMPEG
+class CvCapture_FFMPEG: public octave_base_value
 {
+  public:
+    CvCapture_FFMPEG ();
+
     bool open( const char* filename );
     void close();
 
@@ -528,10 +542,27 @@
 #if USE_AV_INTERRUPT_CALLBACK
     AVInterruptCallbackMetadata interrupt_metadata;
 #endif
+
+  bool is_constant (void) const
+  {
+    return true;
+  }
+  bool is_defined (void) const
+  {
+    return true;
+  }
+
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(CvCapture_FFMPEG, "CvCapture_FFMPEG", "CvCapture_FFMPEG");
+
+CvCapture_FFMPEG::CvCapture_FFMPEG ()
+  : octave_base_value () { init (); };
+
 void CvCapture_FFMPEG::init()
 {
+    av_register_all();
     ic = 0;
     video_stream = -1;
     video_st = 0;
@@ -891,6 +922,13 @@
     int err = av_open_input_file(&ic, _filename, NULL, 0, NULL);
 #endif
 
+//fprintf(stderr, "err = %i %s %i %i\n", err, icvFFMPEGErrStr(err), LIBAVUTIL_BUILD, CALC_FFMPEG_VERSION(52, 111, 0));
+
+char buf[50];
+av_strerror (err, buf, 50);
+fprintf (stderr, "%s\n", buf);
+
+
     if (err < 0)
     {
         CV_WARN("Error opening file");
@@ -1098,7 +1136,7 @@
                 buffer_width, buffer_height,
                 video_st->codec->pix_fmt,
                 buffer_width, buffer_height,
-                AV_PIX_FMT_BGR24,
+                AV_PIX_FMT_RGB24,
                 SWS_BICUBIC,
                 NULL, NULL, NULL
                 );
@@ -1159,6 +1197,8 @@
     AVCodecID codec_id = AV_CODEC_ID_NONE;
     const char* codec_fourcc = NULL;
 
+#if 0
+
     switch( property_id )
     {
     case CV_FFMPEG_CAP_PROP_POS_MSEC:
@@ -1203,7 +1243,7 @@
     default:
         break;
     }
-
+#endif
     return 0;
 }
 
@@ -1344,7 +1384,7 @@
 bool CvCapture_FFMPEG::setProperty( int property_id, double value )
 {
     if( !video_st ) return false;
-
+#if 0
     switch( property_id )
     {
     case CV_FFMPEG_CAP_PROP_POS_MSEC:
@@ -1372,14 +1412,19 @@
     default:
         return false;
     }
-
+#endif
     return true;
 }
 
 
 ///////////////// FFMPEG CvVideoWriter implementation //////////////////////////
-struct CvVideoWriter_FFMPEG
+static bool writer_type_loaded = false;
+
+class CvVideoWriter_FFMPEG: public octave_base_value
 {
+  public:
+    CvVideoWriter_FFMPEG ();
+
     bool open( const char* filename, int fourcc,
                double fps, int width, int height, bool isColor );
     void close();
@@ -1403,8 +1448,24 @@
     int               frame_idx;
     bool              ok;
     struct SwsContext *img_convert_ctx;
+
+    bool is_constant (void) const
+    {
+      return true;
+    }
+    bool is_defined (void) const
+    {
+      return true;
+    }
+
+    DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(CvVideoWriter_FFMPEG, "CvVideoWriter_FFMPEG", "CvVideoWriter_FFMPEG");
+
+CvVideoWriter_FFMPEG::CvVideoWriter_FFMPEG ()
+  : octave_base_value () { init (); };
+
 static const char * icvFFMPEGErrStr(int err)
 {
 #if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(53, 2, 0)
@@ -1465,6 +1526,7 @@
 
 void CvVideoWriter_FFMPEG::init()
 {
+    av_register_all();
     fmt = 0;
     oc = 0;
     outbuf = 0;
@@ -2039,54 +2101,63 @@
         return false;
     }
 
+    if (fourcc)
+    {
+
     /* Lookup codec_id for given fourcc */
 #if LIBAVCODEC_VERSION_INT<((51<<16)+(49<<8)+0)
-    if( (codec_id = codec_get_bmp_id( fourcc )) == CV_CODEC(CODEC_ID_NONE) )
-        return false;
+      if( (codec_id = codec_get_bmp_id( fourcc )) == CV_CODEC(CODEC_ID_NONE) )
+          return false;
 #else
-    if( (codec_id = av_codec_get_id(fmt->codec_tag, fourcc)) == CV_CODEC(CODEC_ID_NONE) )
-    {
-        const struct AVCodecTag * fallback_tags[] = {
+      if( (codec_id = av_codec_get_id(fmt->codec_tag, fourcc)) == CV_CODEC(CODEC_ID_NONE) )
+      {
+          const struct AVCodecTag * fallback_tags[] = {
 #if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(54, 1, 0)
 // APIchanges:
 // 2012-01-31 - dd6d3b0 - lavf 54.01.0
 //   Add avformat_get_riff_video_tags() and avformat_get_riff_audio_tags().
-                avformat_get_riff_video_tags(),
+                  avformat_get_riff_video_tags(),
 #endif
 #if LIBAVFORMAT_BUILD >= CALC_FFMPEG_VERSION(55, 25, 100) && defined LIBAVFORMAT_VERSION_MICRO && LIBAVFORMAT_VERSION_MICRO >= 100
 // APIchanges: ffmpeg only
 // 2014-01-19 - 1a193c4 - lavf 55.25.100 - avformat.h
 //   Add avformat_get_mov_video_tags() and avformat_get_mov_audio_tags().
-                avformat_get_mov_video_tags(),
+                  avformat_get_mov_video_tags(),
 #endif
-                codec_bmp_tags, // fallback for avformat < 54.1
-                NULL };
-        if( (codec_id = av_codec_get_id(fallback_tags, fourcc)) == CV_CODEC(CODEC_ID_NONE) )
+                  codec_bmp_tags, // fallback for avformat < 54.1
+                  NULL };
+          if( (codec_id = av_codec_get_id(fallback_tags, fourcc)) == CV_CODEC(CODEC_ID_NONE) )
+          {
+              fflush(stdout);
+              fprintf(stderr, "OpenCV: FFMPEG: tag 0x%08x/'%c%c%c%c' is not found (format '%s / %s')'\n",
+                      fourcc, CV_TAG_TO_PRINTABLE_CHAR4(fourcc),
+                      fmt->name, fmt->long_name);
+              return false;
+          }
+        }
+
+        // validate tag
+        if (cv_ff_codec_tag_list_match(fmt->codec_tag, codec_id, fourcc) == false)
         {
             fflush(stdout);
-            fprintf(stderr, "OpenCV: FFMPEG: tag 0x%08x/'%c%c%c%c' is not found (format '%s / %s')'\n",
+            fprintf(stderr, "OpenCV: FFMPEG: tag 0x%08x/'%c%c%c%c' is not supported with codec id %d and format '%s / %s'\n",
                     fourcc, CV_TAG_TO_PRINTABLE_CHAR4(fourcc),
-                    fmt->name, fmt->long_name);
-            return false;
+                    codec_id, fmt->name, fmt->long_name);
+            int supported_tag;
+            if( (supported_tag = av_codec_get_tag(fmt->codec_tag, codec_id)) != 0 )
+            {
+                fprintf(stderr, "OpenCV: FFMPEG: fallback to use tag 0x%08x/'%c%c%c%c'\n",
+                        supported_tag, CV_TAG_TO_PRINTABLE_CHAR4(supported_tag));
+                fourcc = supported_tag;
+            }
         }
     }
-
-
-    // validate tag
-    if (cv_ff_codec_tag_list_match(fmt->codec_tag, codec_id, fourcc) == false)
+    else // fourcc == 0
     {
-        fflush(stdout);
-        fprintf(stderr, "OpenCV: FFMPEG: tag 0x%08x/'%c%c%c%c' is not supported with codec id %d and format '%s / %s'\n",
-                fourcc, CV_TAG_TO_PRINTABLE_CHAR4(fourcc),
-                codec_id, fmt->name, fmt->long_name);
-        int supported_tag;
-        if( (supported_tag = av_codec_get_tag(fmt->codec_tag, codec_id)) != 0 )
-        {
-            fprintf(stderr, "OpenCV: FFMPEG: fallback to use tag 0x%08x/'%c%c%c%c'\n",
-                    supported_tag, CV_TAG_TO_PRINTABLE_CHAR4(supported_tag));
-            fourcc = supported_tag;
-        }
+      // use default codec
+      codec_id = fmt->video_codec;
     }
+
 #endif
 
     // alloc memory for context
